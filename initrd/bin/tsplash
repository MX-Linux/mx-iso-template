#!/live/bin/bash

#==============================================================================
# Create a text based "splash screen" for starting live MX/antiX
#
# We rely on the openvt command to draw-on/work-in in a given tty.
#
# (C) 2019 Paul Banham <antiX@operamail.com>
# License: GPLv3 or later
#==============================================================================

ME=${0##*/}
ME=${ME#_}

#DB_HEIGHT=25
DEF_SCREEN_WIDTH=100
WELCOME_Y_OFFSET=-4
RAW_SCREEN_HEIGHT=24

RAW_Y0=1
Y0=1
X0=1

CONF_FILE="/live/etc/tsplash.conf"

VERBOSE_PROGRESS=true
SHOW_BORDER=true
SHOW_NAV=true

MAX_PROGRESS=7
PROG_CHARS=5

CONF_DIR=/live/config
WORK_DIR=$CONF_DIR/tsplash
LANG_FILE=$CONF_DIR/lang

  WELCOME_FILE=$WORK_DIR/welcome
     PROG_FILE=$WORK_DIR/progress
      LOG_FILE=$WORK_DIR/$ME.log
      TTY_FILE=$WORK_DIR/tty
  TTY_NUM_FILE=$WORK_DIR/tty-num
       FIFO_IN=$WORK_DIR/fifo
  MY_CONF_FILE=$WORK_DIR/config

  PROG_BAR_WIDTH=100

C_DOT="\u2022"
C_DOT="•"

FONT_DIRS="/usr/share/consolefonts /live/locale/fonts"

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
main() {
    local cmd=$1 ; shift

    PATH=$PATH:/live/bin

    stty cbreak -echo

    printf "\e[?25l"  # cursor off
    MY_TTY=$(tty)

    case $MY_TTY in
        /dev/tty*) TTY_NUM=${MY_TTY#/dev/tty} ;;
                *) fatal "$ME can only be run in a virtual console %s" "$MY_TTY" ;;
    esac


    case $cmd in
         start)  do_start "$@" ; exit  0 ;;
    esac

    #echo -e "\n---------------------------" >> $LOG_FILE
    log_it "cmd: %s" "$cmd $*"

    # Read back our configuration
    /live/bin/bash -n $MY_CONF_FILE 2>/dev/null 1>/dev/null && . $MY_CONF_FILE

    #TTY_NUM=$(cat $TTY_NUM_FILE 2>/dev/null)
    #[ -z "$TTY_NUM" ] && fatal "Could not find the tty number in %s" "$TTY_NUM_FILE"
    #openvt -c $TTY_NUM

    WELCOME_MSG=$(cat $WELCOME_FILE 2>/dev/null)
    eval_cmd "$cmd" "$@"
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
eval_cmd() {
    local cmd=$1 ; shift

    case $cmd in
         prog-bar) test_prog_bar      ;;
           redraw) do_redraw          ;;
     redraw-clear) do_redraw_clear    ;;
            clear) clear              ;;
         progress) do_progress "$@"   ;;
   clear-progress) clear_progress     ;;

        udev-rule) do_redraw          ;;
       udev-start) do_clear
                   echo udev-start >> $PROG_FILE ;;

         udev-end) udev_end           ;;
            final) do_final           ;;

        shutdown) clear_progress $cmd ;;
          reboot) clear_progress $cmd ;;

                *) fatal "Unknown command %s" "$cmd" ;;
    esac

    exit 0
}

do_clear() {
    log_it clear
    clear
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
udev_end() {
    echo -e "udev-end" >> $PROG_FILE
    do_redraw $((MAX_PROGRESS - 1))
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
do_final() {
    echo -e "final" >> $PROG_FILE
    do_redraw $MAX_PROGRESS
}


#------------------------------------------------------------------------------
# Set up our work directory and then draw/redraw the screen
#------------------------------------------------------------------------------
do_start() {
    local param=$1
    # Set up files under /live/config/tsplash

    rm -rf   "$WORK_DIR"
    mkdir -p "$WORK_DIR"

    local start_t=$(get_seconds $(cut -d" " -f22 /proc/$$/stat))

    printf  "[%8s] Started %s with '%s'\n" "$start_t" "$ME" "$param" >> $LOG_FILE

    test -r $CONF_FILE && /live/bin/bash $CONF_FILE &>/dev/null && . $CONF_FILE

    # Read back what we stored when we started
    LANG=$(cat $LANG_FILE 2>/dev/null)

    if [ -n "$param" ]; then
        [ -z "${param##*[ba]*}" ] && SHOW_BORDER=true
        [ -z "${param##*[BA]*}" ] && SHOW_BORDER=
        [ -z "${param##*[pa]*}" ] && VERBOSE_PROGRESS=true
        [ -z "${param##*[PA]*}" ] && VERBOSE_PROGRESS=
        [ -z "${param##*[na]*}" ] && SHOW_NAV=true
        [ -z "${param##*[NA]*}" ] && SHOW_NAV=
    fi

    cat <<Config > $MY_CONF_FILE
VERBOSE_PROGRESS=$VERBOSE_PROGRESS
SHOW_BORDER=$SHOW_BORDER
SHOW_NAV=$SHOW_NAV
LANG=$LANG
Config

    local WELCOME_MSG=$(get_welcome_msg)
    echo "$WELCOME_MSG" > $WELCOME_FILE
    log_it "$WELCOME_MSG"

    touch $PROG_FILE
    #echo "start" >> $PROG_FILE

    do_redraw
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
do_fifo() {
    local cmd line
    rm -f $FIFO_IN
    mkfifo $FIFO_IN
    log 'start FIFO'
    read_state
    local stdin=$(readlink -f /proc/$$/fd/0)
    log "stdin: $stdin"
    while : ; do
        while read cmd line; do
            log_it "fifo: cmd=$cmd line=$line"
            eval_command "$cmd" $line
        done < $FIFO_IN
    done
}


#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
do_progress() {
    echo "$*" >> $PROG_FILE
    set_color
    screen_init
    show_progress
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
clear_progress() {
    local cmd=$1
    set_color
    screen_init
    blank_line $PROG_Y
    blank_line $PROG_Y2
    [ -z "$cmd" ] && return
    ctext $PROG_Y "" "$cmd" $bold_co
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
do_redraw_clear() {
    do_redraw 0
    clear_progress
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
do_redraw() {
    local cnt=$1
    log_it "redraw on %s" "$(tty)"
    clear
    set_color
    set_console_width
    screen_init

    [ -n "$SHOW_BORDER" ] && box $SCREEN_BOX $lt_cyan

    #log_it "welcome: $WELCOME_MSG"

    ctext "$WELCOME_Y" "" "$WELCOME_MSG" "$lt_cyan"

    show_progress $cnt
    [ -n "$SHOW_NAV" ] && draw_nav_keys
}

#------------------------------------------------------------------------------
# Show a string of dots with some of them highlighted.  The number highlighted
# is the number of lines in the "progress" file.
#------------------------------------------------------------------------------
show_progress() {
    local p_cnt=${1:-$(cat $PROG_FILE 2>/dev/null | wc -l)}

    local y=$PROG_Y
    local x=$PROG_X

    printf "$bold_co\e[$y;${x}H"
    for cnt in $(seq 1 $MAX_PROGRESS); do
        [ $cnt -gt ${p_cnt:-0} ] && printf "$dk_grey"
        printf "%-${PROG_CHARS}s" "$C_DOT"
    done
    printf "$nc_co"

    [ -n "$VERBOSE_PROGRESS" ] || return

    local last_msg=$(tail -n1 $PROG_FILE)
    [ -n "$last_msg" ] || return

    local y2=$PROG_Y2
    blank_line $y2
    ctext $y2 "" "$last_msg"   $lt_grey
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
get_welcome_msg() {
    read_distro_release /etc/initrd-release
    : ${DISTRO_BUG_REPORT_URL:=$BUG_REPORT_URL}
    : ${DISTRO_NAME:=antiX}
    : ${DISTRO_PRETTY_NAME:=antiX-17 (generic)}
    do_welcome "$DISTRO_PRETTY_NAME"
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
get_seconds() {
    local msecs=${1:-$(cut -d" " -f22 /proc/self/stat)}
    printf "%06d" $msecs | sed  -r 's/(..)$/.\1/'
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
draw_nav_keys() {

    local left_press=$(mk_key_str  "%s boot process" "Alt-F1")
    local right_press=$(mk_key_str "%s return here"  "Alt-$TTY_NUM")

    left_text  $((SCREEN_BOTTOM))  "  $left_press"
    right_text $((SCREEN_BOTTOM))  "$right_press  "
}

#------------------------------------------------------------------------------
# Blank out a line but stay away from the edges
#------------------------------------------------------------------------------
blank_line() {
    local y=$1
    printf "\e[$y;${SCREEN_X0}H%${SCREEN_WIDTH}s" ""
}



#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
mk_key() {
    local key=$1 c1=$amber c2=$lt_grey
    echo  "<$c1$key$c2>"
}

mk_key_str() {
    local str=$1  key=$2
    printf "$lt_grey$str$nc_co" "$(mk_key "$key")"
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
read_distro_release() {
    local file=$1
    test -r "$file" || return
    eval $(sed -r -n 's/^\s*([A-Z0-9_]+=)/DISTRO_\1/p' $file)
}
#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
set_console_width() {
    local width=$DEF_SCREEN_WIDTH   lang=$LANG
    local def_size=8  name=Terminus  ext=.psf

    local dir fdir
    for dir in $FONT_DIRS; do
        test -d $dir || continue
        fdir=$dir
        break
    done

    [ -n "$fdir" ] || fatal "could not find a font directory"
    [ "$fdir" = /usr/share/consolefonts ] && ext=.psf.gz

    local code
    case ${lang%%_*} in
                     kk|ky|tj) code='CyrAsia'  ;;
                        ru|uk) code='CyrKoi'   ;;
                  bg|mk|ru|sr) code='CyrSlav'  ;;
      bs|hr|cs|hu|pl|ro|sk|sl) code='Lat2'     ;;
        af|sq|ast|da|nl|et|fr) code='Lat15'    ;;
    'fi'|de|is|id|pt|es|sv|tr) code='Lat15'    ;;
                        lt|lv) code='Lat7'     ;;
                           el) code='Greek'    ;;
                            *) code='Uni2'     ;;
    esac

    local font file
    # This loop only runs at most once.  Use "break" for control flow
    while true; do

        test -e /dev/fb0 || break

        #log_it "width $width"

        case $width in
            [1-9][0-9]|[1-9][0-9][0-9]) ;;
            off) break ;;
              *) fatal "Invalid %s value %s" "$conwidth" "$width"
                 break ;;
        esac

        # Make sure we have at least 80 chars per line
        local min_width=${MIN_SCREEN_WIDTH:-80}
        [ $width -lt $min_width ] && width=$min_width

        local pixel_width=$(get_fbcondecor_width)
        #log_it "pixel_width $pixel_width"

        log_it 'Width of screen in pixels %s'  "$pixel_width"
        [ -z "$pixel_width" ] && break
        local cmd_size=$((pixel_width / width))

        #log_it 'Try to set line length to %s'  "$width"
        #log_it 'Using size %s'                 "$cmd_size"

        local size
        case $cmd_size in
                  [1-7]) size=12x6                ;;
                   [89]) size=16                  ;;
                     10) size=20x10               ;;
                     11) size=22x11               ;;
                  1[23]) size=24x12               ;;
                  1[45]) size=28x14               ;;
                1[6789]) size=32x16               ;;
           [23456][0-9]) size=32x16               ;;
        esac

        local try  f_size  f_face
        for f_size in $size $def_size; do
            for f_face in ${name}Bold VGA $name; do
                try=$code-$f_face$f_size
                #log_it "try: $try"
                file=$dir/$try$ext
                test -e $file || continue
                font=$try
                break
            done
            [ "$font" ] && break
        done

        break
    done

    #log_it "fdir $fdir"
    #log_it "file $file"
    # If we didn't find a font, fall back to VGA16 so we still
    # get the right unicode chars for the chosen language
    if [ -z "$font" ]; then
        font=$code-VGA16
        file=$fdir/$font$ext
        test -e $file || return 2
    fi

     log_it "Set font to %s" "$font"

    setfont $file -C $(tty)

    SCREEN_WIDTH=$(stty size 2>/dev/null | cut -d" " -f2)
    log_it "New screen width %s"  "$SCREEN_WIDTH"
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
get_fbcondecor_width() {
    local theme=${1:-default}  res
    local res=$(cat /sys/class/graphics/fb0/virtual_size 2>/dev/null)
    [ -z "$res" ] && return
    if test -e /dev/fbcondecor-jbb; then
        local file=/etc/splash/$theme/${res/,/x}.cfg
        test -r $file || return
        sed -rn "s/^\s*tw=([0-9]+).*/\1/p" $file | tail -n1
    else
        echo ${res%%,*}
    fi
}

#------------------------------------------------------------------------------
# Log time and message to log file
#------------------------------------------------------------------------------
log_it() {
    local fmt=$1 ; shift
    printf "[%8s] $fmt\n" "$(get_seconds)" "$@" >> $LOG_FILE
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
fatal() {
    local fmt=$1 ; shift
    printf "[%8s] Fatal: $fmt\n" "$(get_seconds)" "$@" >> $LOG_FILE
    exit 2
}

error() {
    local fmt=$1 ; shift
    printf "[%8s] Error: $fmt\n" "$(get_seconds)" "$@" >> $LOG_FILE
    exit 2
}


#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
pq()      { echo "$hi_co$*$m_co"           ;}
pqw()     { echo "$hi_co$*$m_co"           ;}
#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------

#==============================================================================
#==============================================================================
#=======  OLD CODE STARTS HERE ================================================
#==============================================================================
#==============================================================================
#==============================================================================


#------------------------------------------------------------------------------
# Create the geometry of the screen
#------------------------------------------------------------------------------

screen_init() {

    : ${SCREEN_BORDER:=1}

    RAW_X0=1 ; RAW_Y0=1
    RAW_SCREEN_WIDTH=${WIDTH:-$(  stty size | cut -d" " -f2)}
    RAW_SCREEN_HEIGHT=${HEIGHT:-$(stty size | cut -d" " -f1)}

    RAW_SCREEN_HEIGHT=${DB_HEIGHT:-$RAW_SCREEN_HEIGHT}

    REAL_HEIGHT=$RAW_SCREEN_HEIGHT

    SCREEN_X0=$((SCREEN_BORDER + RAW_X0))
    SCREEN_Y0=$((SCREEN_BORDER + RAW_Y0))

    SCREEN_HEIGHT=$((RAW_SCREEN_HEIGHT - 2 * SCREEN_BORDER))
    SCREEN_WIDTH=$(( RAW_SCREEN_WIDTH  - 2 * SCREEN_BORDER))

    log_it "SCREEN_WIDTH: $SCREEN_WIDTH"

    SCREEN_BOTTOM=$((RAW_SCREEN_HEIGHT - 1))

    CENTER_Y=$((SCREEN_HEIGHT / 2 + RAW_Y0))
    CENTER_X=$((RAW_SCREEN_WIDTH / 2))

    SCREEN_BOX="$RAW_X0 $RAW_Y0 $RAW_SCREEN_WIDTH $RAW_SCREEN_HEIGHT"

    WELCOME_Y=$((CENTER_Y + WELCOME_Y_OFFSET))
    PROG_Y=$((WELCOME_Y +  2))
    PROG_Y2=$((PROG_Y + 2))
    BAR_Y1=$(( SCREEN_HEIGHT * 3 / 4))
    #BAR_Y1=$((PROG_Y + 4))

    PROG_X=$(((RAW_SCREEN_WIDTH - MAX_PROGRESS * PROG_CHARS / 2) / 2))

}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
set_color() {
    local e=$(printf "\e")
     black="$e[0;30m";    blue="$e[0;34m";    green="$e[0;32m";    cyan="$e[0;36m";
       red="$e[0;31m";  purple="$e[0;35m";    brown="$e[0;33m"; lt_gray="$e[0;37m";
   dk_grey="$e[1;30m"; lt_blue="$e[1;34m"; lt_green="$e[1;32m"; lt_cyan="$e[1;36m";
    lt_red="$e[1;31m"; magenta="$e[1;35m";   yellow="$e[1;33m";   white="$e[1;37m";
     nc_co="$e[0m";                           amber="$e[0;33m"; lt_grey="$e[0;37m";

    cheat_co=$white;      err_co=$red;       hi_co=$white;
      cmd_co=$white;     from_co=$lt_green;  mp_co=$magenta;   num_co=$magenta;
      dev_co=$magenta;   head_co=$yellow;     m_co=$lt_cyan;    ok_co=$lt_green;
       to_co=$lt_green;  warn_co=$yellow;  bold_co=$yellow;

    clear="$e[2;J"; cursor_off="$e[?25l"; cursor_on="$e[?25h"

    SCREEN_BORDER_COLOR=$grey

    printf $nc_co

}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
screen_draw_box() {
    SCREEN_DID_BOX=
    [ -n "$SCREEN_BOX_STYLE" -a -n "$SCREEN_BOX" ] || return
    SCREEN_DID_BOX=true
    box $SCREEN_BOX_STYLE $SCREEN_BOX $SCREEN_BORDER_COLOR
}

# box flag x y width heigh color

#------------------------------------------------------------------------------
# Draw a box in a certain style and with a color
# Style is set with -X flags.
#------------------------------------------------------------------------------
box() {
    local flag
    while [ $# -gt 0 -a -z "${1##-*}" ]; do
        flag=$flag${1#-}
        shift
    done

    #return
    local x0=$1 y0=$2 width=$3 height=$4 color=$5

    [ "$color" ] && printf "$nc$color"

    local iwidth=$((width - 2))
    local x1=$((x0 + width - 1))

    #-- Set up line style and colors

    [ "$ASCII_ONLY" ] && flag=A$flag
    case $flag in
      Ac) local hbar=' ' vbar=' ' tl_corn=' ' bl_corn=' ' tr_corn=' ' br_corn=' ' ;;
      Ad) local hbar='=' vbar='|' tl_corn='#' bl_corn='#' tr_corn='#' br_corn='#' ;;
      A*) local hbar='-' vbar='|' tl_corn='+' bl_corn='+' tr_corn='+' br_corn='+' ;;
       c) local hbar=' ' vbar=' ' tl_corn=' ' bl_corn=' ' tr_corn=' ' br_corn=' ' ;;
       b) local hbar='━' vbar='┃' tl_corn='┏' tr_corn='┓' bl_corn='┗' br_corn='┛' ;;
       d) local hbar='═' vbar='║' tl_corn='╔' tr_corn='╗' bl_corn='╚' br_corn='╝' ;;
       *) local hbar='─' vbar='│' tl_corn='┌' tr_corn='┐' bl_corn='└' br_corn='┘' ;;
    esac

    local bar=$(printf "%${iwidth}s" | sed "s/ /$hbar/g")
    printf "\e[$y0;${x0}H$tl_corn$bar$tr_corn"
    local y
    for y in $(seq $((y0 + 1)) $((y0 + height - 2))); do
        printf "\e[$y;${x0}H$vbar"
        printf "\e[$y;${x1}H$vbar"
    done
    printf "\e[$((y0 + height - 1));${x0}H$bl_corn$bar$br_corn"
}


#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
cruler() {
    local i y midx
    for y in $(echo "$1" | sed 's/,/ /g'); do
        y=$(($y + SCREEN_Y0)) color=$2
        midx=$((RAW_SCREEN_WIDTH/2))
        printf "\e[$y;1H$color"
        for i in $(seq 1 $midx); do
            printf $((i % 10))
        done

        for i in $(seq 1 $midx); do
            printf "\e[$y;$((RAW_SCREEN_WIDTH -i + 1))H"
            printf $((i % 10))
        done
        printf $nc
    done
}

#======================================================================
# Strings
#======================================================================

# Note, the 2nd regex helps shells that don't know about unicode as long as sed
# is unicode-aware then you are okay.  Unfortunately BusyBox sed doesn't work
# here for stripping colors.  So we CHEAT and use . instead of \x1B

str_len() {
    echo -n "$*" | sed -r -e 's/.\[[0-9;]+[mK]//g' | wc -m
}

str_rtrunc() {
    local msg=$(echo "$1" | sed -r 's/.\[[0-9;]+[mK]//g')
    local len=$2
    echo "$msg" | sed -r "s/(.{$len}).*/\1/"
}

str_ltrunc() {
    local msg=$(echo "$1" | sed -r 's/.\[[0-9;]+[mK]//g')
    local len=$2
    echo "$msg" | sed -r "s/.*(.{$len})$/\1/"
}

text_right() {
    local x=$1  y=$2 msg=$3  len=$(str_len "$3")

    local avail=$((${SCREEN_WIDTH:-78} - x + 1))
    [ $avail -lt 0 ] && avail=78
    local pad=$((avail - len))
    [ $pad -lt 0 ] && pad=0
    #msg=$(str_rtrunc "$3" $avail)
    printf "\e[$y;${x}H%s%${pad}s" "$msg" ""
}

ctext() {
    local y=$1 x0=${2:-$((RAW_SCREEN_WIDTH / 2))} msg=$3 color=$4
    local len=$(str_len "$msg")
    local x=$((1 + x0 - len/2))
    printf "$color\e[$y;${x}H$msg"
}

goto() {
    local x=${1-1}  y=${2:-1}
    printf "\e[$y;${x}H"
}

cline() {
    local y=$1 msg=$2 color=$3
    [ "$msg" ] || return
    msg=$(echo "$msg" | sed "s/<color>/$color/g")

    local x=$SCREEN_X0
    local len=$(str_len "$msg")
    local width=$SCREEN_WIDTH
    [ $len -ge $width ] && msg=$(str_rtrunc "$msg" $width)
    local pad1=$(( (width - len) / 2))
    local pad2=$((width - len - pad1))
    printf "\e[$y;${x}H$color%${pad1}s%s%${pad2}s" "" "$msg" ""
}

left_text() {
    local y=$1 x=$((SCREEN_X0 + 1))
    shift
    local msg=$(printf "$@")
    printf "\e[$y;${x}H$color$msg"
}

right_text() {
    local y=$1
    shift
    local msg=$(printf "$@")
    local len=$(str_len "$msg")
    local x=$((SCREEN_WIDTH - len + SCREEN_X0 - 1))
    printf "\e[$y;${x}H$color$msg"
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
do_welcome() {
    local pretty_name=$1 version=$2  v_date=$3  arch
    case $(uname -m) in
          i686) arch=" 32-bit" ;;
        x86_64) arch=" 64-bit" ;;
    esac

    case $(uname -r) in
        *[pP][aA][eE]) arch="$arch pae" ;;
    esac

    pretty_name="$pretty_name$arch"
    echo "$pretty_name"

}


#------------------------------------------------------------------------------
# Do a "dd" command with a progress bar
#------------------------------------------------------------------------------
prog_dd() {
    local dest=$1  cnt=$2  src=${3:-/dev/zero}  bs=${4:-1M}

    local err_file=/dd-copy-failed
    # TEST directories or fatal error

    mkdir -p "$(dirname "$dest")"

    rm -f "$file"
    local final_size=$cnt  base_size=0

    local dirty_ratio dirty_bytes
    read dirty_ratio < /proc/sys/vm/dirty_ratio
    read dirty_bytes < /proc/sys/vm/dirty_bytes
    echo $USB_DIRTY_BYTES > /proc/sys/vm/dirty_bytes

    rm -f $err_file
    (dd if=$src of=$dest bs=$bs count=$cnt status=none || echo $? > $err_file) &
    COPY_PID=$!
    #echo "copy pid: $COPY_PID" >> $LOG_FILE

    local cur_size=$base_size cur_pct last_pct=0
    while true; do
        if ! test -d /proc/$COPY_PID; then
            echo 1000
            break
        fi
        sleep 0.1

        cur_size=$(du_size $dest)
        cur_pct=$((cur_size * 1000 / final_size))
        [ $cur_pct -gt $last_pct ] || continue
        echo $cur_pct
        last_pct=$cur_pct

    done | text_progress

    echo

    sync ; sync

    # Enable cursor
    printf "\e[?25h"

    echo $dirty_bytes >> /proc/sys/vm/dirty_bytes
    echo $dirty_ratio >> /proc/sys/vm/dirty_ratio

    # Use err_file as a semaphore from (...)& process
    if test -e $err_file; then
        rm -f $err_file
        return 2
    fi

    test -d /proc/$COPY_PID && wait $COPY_PID

    return 0
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
bar_box() {
    local width=$((80 * SCREEN_WIDTH / 100 + 2))
    local x1=$((CENTER_X - width / 2))
    local y1=$((BAR_Y1 - 1))
    local height=3

    log_it "box $CENTER_X | $SCREEN_WIDTH |  $x1 | $y1 | $width | $height"
    box $x1 $y1 $width $height $lt_cyan
}

#------------------------------------------------------------------------------
# Do a "dd" command with a progress bar
#------------------------------------------------------------------------------
test_prog_bar() {
    set_color
    screen_init
    local dest=$1  cnt=$2  src=${3:-/dev/zero}  bs=${4:-1M}

    bar_box
    exit

    local err_file=/dd-copy-failed
    # TEST directories or fatal error

    #mkdir -p "$(dirname "$dest")"

    rm -f "$file"
    local final_size=$cnt  base_size=0

    local dirty_ratio dirty_bytes
    read dirty_ratio < /proc/sys/vm/dirty_ratio
    read dirty_bytes < /proc/sys/vm/dirty_bytes
    echo $USB_DIRTY_BYTES > /proc/sys/vm/dirty_bytes

    #rm -f $err_file
    #(dd if=$src of=$dest bs=$bs count=$cnt status=none || echo $? > $err_file) &
    #COPY_PID=$!
    #echo "copy pid: $COPY_PID" >> $LOG_FILE

    local cur_size=$base_size cur_pct last_pct=0
    while true; do
        sleep 0.1
        cur_pct=$((cur_pct + 1))
        [ $cur_pct -gt $last_pct ] || continue
        echo $cur_pct
        last_pct=$cur_pct

    done | text_progress

    echo

    #sync ; sync

    # Enable cursor

    #echo $dirty_bytes >> /proc/sys/vm/dirty_bytes
    #echo $dirty_ratio >> /proc/sys/vm/dirty_ratio

    # Use err_file as a semaphore from (...)& process
    if test -e $err_file; then
        rm -f $err_file
        return 2
    fi

    #test -d /proc/$COPY_PID && wait $COPY_PID

    return 0
}

#------------------------------------------------------------------------------
# This acts like an external program to draw a progress bar on the screen.
# It expects integer percentages as input on stdin to move the bar.
# Now using 1/10th percent steps which seems to reduce jitteriness/jaggedness.
# Yes, because there was aliasing between 100 steps and width of screen.
#------------------------------------------------------------------------------
text_progress() {
    local abs_max_x=$((SCREEN_WIDTH * 90 / 100))
    local min_x=$((SCREEN_WIDTH * 10 / 100))
    local y=${PROG_BAR_Y:-$((1 + SCREEN_HEIGHT * 3 / 4))}

    # length of ">100%" plus one = 6 (??)
    local max_x=$((abs_max_x - 7))

    # Create end-points and save our location on the screen
    printf "\e[s$from_co|$nc_co\e[u"
    #printf "\e[u\e[$((max_x + 2))C$from_co|$nc_co\e[u"

    local cur_x last_x=$min_x  delta_x=$((max_x - min_x))
    while read input; do
        case $input in
            [0-9]|[0-9][0-9]|[0-9][0-9][0-9]) ;;
                        [0-9][0-9][0-9][0-9]) ;;
            *) break;;
        esac

        [ $input -gt 1000 ] && input=1000
        cur_x=$((min_x + max_x * input / 1000))
        # Note we always draw entire bar to avoid problems when switching
        # virtual terminals while the bar is being drawn

        [ $cur_x -le $last_x ] && continue
        # Draw the bar
        printf "\e[u\e[0C$m_co%${delta_x}s$bold_co>$nc_co\e[u" | tr ' ' '='
        # Show the percentage
        printf "\e[$((max_x + 2))C%3s%%" "$((input / 10))"

        last_x=$cur_x

        [ $input -ge 1000 ] && break
    done
}

mkdir -p $WORK_DIR
# main "$@" 2>> $LOG_FILE
main "$@"
